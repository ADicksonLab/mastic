
* New stuff

** TODO [#B] write goals/milestones for mast                      :lab:mastic:
** TODO [#B] test pistacking on real pdb structure       :lab:mastic:analysis:
RDKit is causing me issues with not recognizing aromatic rings on
proteins.

Writing the Polymer and Protein submodules should fix that.

** TODO [#B] HydrophobicContacts interaction type class      :lab:mastic:code:
** TODO [#B] PiCation interaction type class                 :lab:mastic:code:

Mostly done, however some issues need to be resolved:
**** TODO implement special case for tertiary amines
**** TODO figure out how to find cation features with RDKit
** TODO [#B] persistent (not-pickled) datastructure for a system-type :lab:mastic:code:

** TODO [#B] docstrings and doctest for mast                 :lab:mastic:code:
** TODO [#B] unit tests for mast                             :lab:mastic:code:
** TODO [#B] logging for mast                                :lab:mastic:code:
** TODO [#B] write all major interaction classes for mast    :lab:mastic:code:
** TODO [#B] Write Protein submodule                         :lab:mastic:code:
**** TODO [#B] Write protein feature finder                   :lab:mastic:code:
Thinking about the architecture of this.

I want this to make it quick to find features for polymers with
possibly different subunits like proteins. So it what it should do is
need to receive a sequence of polymer subunit labels or types (say
amino acid codes) and return all the FeatureTypes in the overall
molecule.

This requires that there be subunit definitions somewhere. That is if
I say GlycineType as one of the subunits it should look somewhere for
a list of indexed FeatureTypes that have been identified by some other
feature finding software. 

So, what I need to write is a class that can be instantiated with
featuretypes without intrinsically numbered names that is used as a
template for enumerating the features of a polymer.

I guess this is more basic than protein things and requires a polymer
module with PolymerType, Polymer, PolymerSubunitType, and
PolymerSubunit classes. Which I have talked about before.

**** TODO [#B] write polymer submodule                        :lab:mastic:code:

**** TODO [#B] PolymerType                                    :lab:mastic:code:
**** TODO [#B] Polymer                                         :lab:matic:code:
**** TODO [#B] PolymerSubunitType                             :lab:mastic:code:
**** TODO [#B] PolymerSubunit                                 :lab:mastic:code:
**** TODO [#B] Amino acid PolymerSubunitType classes          :lab:mastic:code:
****** TODO alanine
****** TODO cysteine
****** TODO Aspartate
****** TODO Aspartic acid
****** TODO glutamate
****** TODO glutamic acid
****** TODO phenylalanine
****** TODO glycine
****** TODO histidine
****** TODO idoleucine
****** TODO lysine
****** TODO leucine
****** TODO methionine
****** TODO asparagine
****** TODO pyrrolysine
****** TODO proline
****** TODO glutamine
****** TODO arginine
****** TODO serine
****** TODO threonine
****** TODO selenocysteine
****** TODO valine
****** TODO tryptophan
****** TODO tyrosine
****** TODO N-terminal
****** TODO C-terminal

** TODO [#B] SystemTypeProfiles dataset results object       :lab:mastic:code:

May not need this in the end, not sure yet.
** TODO [#B] make FeatureTypes dict in MoleculeType into a list :lab:mastic:code:


Will need to change a lot of baked in code from values() or items() to
just slicing or whatever.
** TODO [#B] interaction stats module                        :lab:mastic:code:

#+BEGIN_EXAMPLE
  def make_hbond_df(hbond_metrics, frame_sel=None):
      """Given a dictionary of hbond_record -> [metrics_record, ... ]
  produce a DataFrame from interaction stats across all metrics records."""

      # get statistics on each interaction
      HydrogenBondStatsRecord = namedtuple('StatsRecord',
                               field_names=['HydrogenBondRecord', 'interaction_id',
                                            'distance_mean', 'distance_std',
                                            'distance_min', 'distance_max',
                                            'angle_mean', 'angle_std',
                                            'angle_min', 'angle_max',
                                            'frames',
                                            'freq', ]) # 'norm_freq'

      hbonds = []
      for hbond_idx, item in enumerate(hbond_metrics.items()):
          inx_record = item[0]
          metrics_records = item[1]

          # make a dataframe from the records for only the selections in
          # the frames if given
          if frame_sel is None:
              metrics_df = pd.DataFrame(metrics_records)
          else:
              # assert frame_sel list of int
              # get a list of the records part of this selection
              sel_records = [metric_record for metric_record in metrics_records
                             if metric_record.frame_id in frame_sel]
              # make the df from the selected records only if there were any
              if len(sel_records) == 0:
                  metrics_df = pd.DataFrame({'distance':[],
                                             'angle' : [],
                                             'frame_id' : []})
              else:
                  metrics_df = pd.DataFrame(sel_records)

          # a new dict for stats on a particular non-metric hbond
          hbond = {'HydrogenBondRecord' : inx_record}
          # get stats on things
          hbond['distance_mean'] = metrics_df[['distance']].mean()[0]
          hbond['distance_std'] = metrics_df[['distance']].std()[0]
          hbond['distance_min'] = metrics_df[['distance']].min()[0]
          hbond['distance_max'] = metrics_df[['distance']].max()[0]
          hbond['angle_mean'] = metrics_df[['angle']].mean()[0]
          hbond['angle_std'] = metrics_df[['angle']].std()[0]
          hbond['angle_min'] = metrics_df[['angle']].min()[0]
          hbond['angle_max'] = metrics_df[['angle']].max()[0]
          # add the frames it is a part of
          hbond['frames'] = list(metrics_df['frame_id'])
          hbond['freq'] = len(hbond['frames'])
          hbond['interaction_id'] = hbond_idx
          # make that into a record
          hbond_record = HydrogenBondStatsRecord(****hbond)
          # add it to the list
          hbonds.append(hbond)

      # set those stats in the hbond_df
      hbond_df = pd.DataFrame(hbonds)

      # calculate the normalized frequencies based on the number of
      # total hbonds in the collection
      hbond_df['norm_freq'] = hbond_df['freq'].divide(hbond_df[hbond_df['freq'] > 0].shape[0],
                                                      fill_value=0.0)

      return hbond_df

  # analyze total interaction instances
  inx_instances = []
  for inx_class, instances in hbond_metrics.items():
      num_instances = len(instances)
      inx_instances.append((inx_class, num_instances))
  # make a df of the instance counts
  inx_instances_df = pd.DataFrame(inx_instances, columns=['HydrogenBondRecord', 'num_instances'])
  inx_instances_total = inx_instances_df['num_instances'].sum()
  inx_instances_mean = inx_instances_df['num_instances'].mean()

  print("total number of unique interaction classes: {}".format(inx_instances_df.shape[0]))
  print("total number of interaction instances: {}".format(inx_instances_total))
  print("mean number of interaction instances per interaction class: {}".format(inx_instances_mean))

  # make the df for all the nodes
  hbond_df = make_hbond_df(hbond_metrics)
  # write table
  tryp_dir = "/home/salotz/Dropbox/lab/trypsin/tryp_net"
  interaction_stats_dir = osp.join(tryp_dir, "interaction_stats")
  freqs_path = osp.join(interaction_stats_dir, "interactions.csv")
  hbond_df.to_csv(freqs_path)

#+END_EXAMPLE

** TODO [#C] NoHHydrogenBond classes                        :lab:mastic:code:


* Old stuff
** TODO evaluate the subspace map method in interaction spaces

We need it internally for getting things by their association
and interaction type efficiently.



** TODO finish dataframe exporters using records
** TODO write unit tests
*** DONE selection.py
**** DONE selection classes
*** DONE molecule.py
**** DONE AtomType, BondType, MoleculeType
**** DONE Atom, Bond, Molecule
*** DONE interfaces.rdkit
*** DONE system.py
*** TODO features.py
started
*** TODO interactions.py
started
**** TODO AssociationType
**** TODO Association
**** TODO InteractionType
**** TODO Interaction
**** TODO HydrogenBondType
**** TODO NoHHydrogenBondType
**** TODO HydrogenBondInx
**** TODO NoHHydrogenBondInx

** TODO write doc strings with tests
*** DONE selection.py
*** DONE molecule.py
**** DONE AtomType, BondType, MoleculeType
**** DONE Atom, Bond, Molecule
*** DONE interfaces.rdkit
*** DONE system.py
*** TODO features.py
started
*** TODO interactions.py
started
**** TODO AssociationType
**** TODO Association
**** TODO InteractionType
**** TODO Interaction
**** TODO HydrogenBondType
**** TODO NoHHydrogenBondType
**** TODO HydrogenBondInx
**** TODO NoHHydrogenBondInx


** TODO write logging
*** TODO selection.py
*** TODO molecule.py
**** TODO AtomType, BondType, MoleculeType
**** TODO Atom, Bond, Molecule
*** TODO interfaces.rdkit
*** TODO system.py
*** TODO interactions.py
**** TODO AssociationType
**** TODO Association
**** TODO InteractionType
**** TODO Interaction
**** TODO HydrogenBondType
**** TODO NoHHydrogenBondType
**** TODO HydrogenBondInx
**** TODO NoHHydrogenBondInx


** TODO tests for None selection id

** DONE only find interactions between the association selections
Right now it finds all of interactions between members and just takes
out the intramember interactions.
** TODO implement slice inputs for selection ids
** TODO SystemMemberType class may be needed
Currently I have multiple Type members allowed in a system which are
not identified by anything except their index in the system. Perhaps a
SystemMember class would alleviate this and give consistency to the
different kind of members.

Of course you can just always make you MoleculeTypes and AtomTypes etc
named to reflect that they are indeed different things in the system.
i.e. a protein dimer.
** TODO migrate Association and AssociationTYpe to system.py
** DONE consolidate SystemAssociation and Association to just Association
** DONE unittests with finding features functions
I was reluctant to use these because rdkit gives me trouble sometimes.
** TODO Type.substantiate function
A general function for use every Type class instead of specific
to_molecule and to_atom methods which need to be handled individually,
e.g. in to_system.

** TODO Type class for things to inherit from.
Would at least provide an interface to implement and override. Need
not be too picky.
** TODO coord_array and array_idx constructor options for Molecule constructor
** DONE finish system and molecule getters for atom, bond, molecule etc classes
** DONE automatically set the in_molecule and in_system flags when the registry of elements are changed
** DONE type constructor and to_molecule, to_atom, to_bond
** TODO BondType and MoleculeType methods for getting adjacent AtomTypes
** DONE make the AtomType class declaration like BondType and MoleculeType
** DONE AtomType, BondType, MoleculeType
** TODO AngleType implementation 
** TODO Atom.__getitem__ should retrieve something more meaningful
Like say the dimension component.

** TODO Docstring for register_selection

SHould have an example of a GenericSelection subclass using this.

** TODO Container class implementation
A class for this would reduce redundancy in checking whether each
element is a SelectionMember.

Should allow for insertion of bare containers, like lists, and have
them internally cast to Container classes.

And then the user has the option of declaring them beforehand or not.

** TODO cast elements of containers to SelectionMembers if not specified
Should make it possibly to simply make a Selection from
#+BEGIN_SRC python
  idxsel = IndexedSelection([1,2,3,4], sel=[0,2])
  idxsel[0]

  # returns SelectionMember(1)
#+END_SRC

** DONE Selection class

Right now it makes a dictionary with the keys being the indices from
the sel key-word argument passed in.

Maybe this can stay the same but this leads to obnoxious behavior in
which you don't have a simple list to iterate through but dictionary
records.

Thus I want just a Selection class that simply puts them into a list
and you access them with all the typical list methods.

The IndexedSelection will just be a dictionary with keys enforced to
be >= 0 ints.

*** DONE class

*** DONE docstring
*** DONE tests

** DONE CoordArraySelection refactor inheritance

Do I want it to be a dictionary style or Selection inheritance.
FIgure this out and change in code.

It now just behaves like a list with a manually added data attribute
and a __getitem__ method.

** DONE SelectionType factory

It seems that there should be something for defining a class of
SelectionTypes such that they must have certain attributes.
#+BEGIN_SRC python
  mol_attrs = ['name', 'pdb_symbol', 'atom_types']
  MoleculeType = SelectionTypeFactory(mol_attrs)

  water_type = MoleculeType(name="water",
               pdb_symbol="H2O",
               atom_types=['H', 'H', 'O'])

  coords = np.array([[0,0,1], [1,0,0], [0,1,0]])

  water_type.to_molecule(coords)
#+END_SRC


This pattern more or less is implemented for AtomType, BondType, and
MoleculeType see those for reference.

** DONE refactor RDKitMoleculeType class into reader and MoleculeType class

Most of what is in RDKitMoleculeType should be in MoleculeType and
RDKitMoleculeType just needs to be a thin wrapper of MoleculeType with
the to_molecule_from_conformer(conf_idx) function and a get conformer
function.

That way we can read in an RDKitMoleculeType and use that to cast to
the mastic agnostic MoleculeType for production.

** DONE make the SystemType and AssociationType classes mean something

Currently they are just stubs. They should have their own libraries.

** TODO make the SystemMember class

This will handle the functions for being a part of a system.

I want to implement a function that recursively searches the registry
for something that is in a system for this.

** TODO handle and create angles in MoleculeType
** TODO allow for parametrized overlap tolerances in Molecule.overlaps
** DONE handle intramember_interactions in Association.profile_interactions
eliminated the need for handling


* COMMENT Local variables # Local Variables: # mode: org #
org-todo-keyword-faces: (("TODO" . org-warning) ("WAIT" . "orange")
("DONE" . org-done)) # org-log-done: t # End:
